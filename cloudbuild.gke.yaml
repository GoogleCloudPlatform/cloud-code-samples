# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

steps:
- id: 'build docker image'
  name: 'gcr.io/$PROJECT_ID/skaffold:alpha'
  args: ['build', '-f dotnet/dotnet-hello-world/skaffold.yaml', '-d gcr.io/$PROJECT_ID', '-p cloudbuild']
  dir: 'dotnet/dotnet-hello-world'
  waitFor: ['-']

#- id: 'build docker image'
#  name: 'gcr.io/cloud-builders/docker'
#  args: [
#    'build',
#    '--tag=dotnet-hello-world', 
#    '--tag=gcr.io/$PROJECT_ID/dotnet-hello-world',
#    '--cache-from', 'gcr.io/$PROJECT_ID/dotnet-hello-world:latest',
#    'dotnet/dotnet-hello-world/src/.',
#  ]
#  waitFor: [] 

- id: 'create k8s namespace'
  name: 'gcr.io/cloud-builders/kubectl'
  args: ['create','namespace','test-$BUILD_ID']
  waitFor: ['-'] # start immediately

#- id: 'push dotnet-hello-world'
#  name: 'gcr.io/cloud-builders/docker'
#  args: ['push', 'gcr.io/$PROJECT_ID/dotnet-hello-world']
#  waitFor: ['build docker image']


#- id: 'update image in k8s config'
#  name: 'gcr.io/cloud-builders/gcloud'
#  entrypoint: 'bash'
    #sed -r 's/^(\s*)(image\s*:\s*nginx\s*$)/\1image: apache/' file

 # args: ['container clusters get-credentials staging --zone us-central1-a --project $PROJECT_ID']
 # args: ['-c','find k8s -type f | xargs sed -i "s/PROJECT_ID/$PROJECT_ID/g"']
#  waitFor: ['-']

- id: 'deploy to staging'
  name: 'gcr.io/$PROJECT_ID/skaffold:alpha'
  args: ['deploy', 
         '-f skaffold.yaml', 
         '-d gcr.io/$PROJECT_ID',
         '-p cloudbuild',
         '-l $BUILD_ID',
         '-n test-$BUILD_ID']
  dir: 'dotnet/dotnet-hello-world'
  waitFor: ['build docker image', 'create k8s namespace']

#- id: 'deploy to staging'
#  name: 'gcr.io/cloud-builders/kubectl'
#  args: ['apply', '-f', './dotnet/dotnet-hello-world/kubernetes-manifests/', '--namespace=test-$BUILD_ID'] 
#  waitFor: ['push dotnet-hello-world','create k8s namespace']

#- id: 'get endpoint'
#  name: 'gcr.io/cloud-builders/kubectl'
#  entrypoint: 'bash'
#  args: 
#  - '-c'
#  - |
    # determine which node port the service was exposed on
    #get_nodeport() {
    #  kubectl get service dotnet-hello-world-external --namespace=test-$BUILD_ID -o=jsonpath='{.spec.ports[0].nodePort}' 
    #}

    #until [[ -n "$(get_nodeport)" ]]; do
    #    echo "querying for nodeport"
    #    sleep 3
    #done

    #echo "$(get_nodeport)" > _nodeport # save port for use in next step

    # grab the public IP of a random node
    # (why do this instead of a load balancer? b/c it's faster to instantiate)
    # (and doesn't require additional billable resources)
    # (we can reasonably expect the node to be durable enough to last until the test completes)
    #get_nodeip() {
    #  kubectl get nodes --output jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}'
    #}

    #until [[ -n "$(get_nodeip)" ]]; do
    #    echo "querying for nodeip"
    #    sleep 3
    #done

    #echo $(get_nodeip) > _nodeip # save ip for use in next step

#  waitFor: ['deploy to staging']

#- id: 'integration tests'
#  name: 'gcr.io/cloud-builders/curl'
#  entrypoint: '/bin/bash'
#  args: 
#  - '-c'
#  - |
    ### -r = retries; -i = interval; -k = keyword to search for ###
#    ./test/test-connection.sh -r 20 -i 3 -u http://$(cat _nodeip):$(cat _nodeport)
#    ./test/test-content.sh -r 20 -i 3 -u http://$(cat _nodeip):$(cat _nodeport) -k 'Chocolate Chip'
#  waitFor: ['get endpoint']

#- id: 'delete namespace'
#  name: 'gcr.io/cloud-builders/kubectl'
#  args: ['delete', 'namespaces', 'test-$BUILD_ID']
#  waitFor: ['integration tests']

options:
  env:
    # location/name of GKE cluster (used by all kubectl commands)
    - CLOUDSDK_COMPUTE_ZONE=us-central1-a
    - CLOUDSDK_CONTAINER_CLUSTER=staging
